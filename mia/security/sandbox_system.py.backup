#!/usr/bin/env python3
"""
ğŸ–ï¸ Sandbox System
=================
"""

import os
import sys
import subprocess
import tempfile
import shutil
import logging
import time
import signal
from pathlib import Path
from typing import Any, Dict, List, Optional
from contextlib import contextmanager

class SandboxEnvironment:

    def _get_deterministic_time(self) -> float:
        """Vrni deterministiÄni Äas"""
        return 1640995200.0  # Fixed timestamp: 2022-01-01 00:00:00 UTC

    """Varno sandbox okolje za izvajanje kode"""
    
    def __init__(self):
        self.logger = logging.getLogger("MIA.Sandbox")
        self.temp_dir = None
        self.process = None
        self.timeout = 30  # sekund
        
        # Dovoljeni moduli
        self.allowed_modules = {
            'json', 'math', 'random', 'datetime', 'time',
            'collections', 'itertools', 'functools', 're',
            'string', 'uuid', 'hashlib', 'base64'
        }
        
        # Prepovedane funkcije
        self.forbidden_functions = {
            'eval', 'exec', 'compile', '__import__',
            'open', 'file', 'input', 'raw_input',
            'exit', 'quit', 'reload'
        }
    
    @contextmanager
    def create_sandbox(self):
        """Ustvari sandbox okolje"""
        try:
            # Ustvari zaÄasni direktorij
            self.temp_dir = tempfile.mkdtemp(prefix="mia_sandbox_")
            self.logger.info(f"Sandbox ustvarjen: {self.temp_dir}")
            
            yield self
            
        finally:
            self._cleanup_sandbox()
    
    def execute_code(self, code: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Izvedi kodo v sandbox okolju"""
        try:
            # Validiraj kodo
            if not self._validate_code(code):
                return {
                    "success": False,
                    "error": "Code validation failed",
                    "output": None
                }
            
            # Pripravi sandbox context
            sandbox_context = self._prepare_sandbox_context(context or {})
            
            # Izvedi kodo
            result = self._execute_in_sandbox(code, sandbox_context)
            
            return result
            
        except Exception as e:
            self.logger.error(f"Napaka pri izvajanju kode: {e}")
            return {
                "success": False,
                "error": str(e),
                "output": None
            }
    
    def _validate_code(self, code: str) -> bool:
        """Validiraj kodo pred izvajanjem"""
        # Preveri prepovedane funkcije
        for forbidden in self.forbidden_functions:
            if forbidden in code:
                self.logger.warning(f"Prepovedana funkcija: {forbidden}")
                return False
        
        # Preveri import stavke
        import ast
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if alias.name not in self.allowed_modules:
                            self.logger.warning(f"Prepovedan modul: {alias.name}")
                            return False
                elif isinstance(node, ast.ImportFrom):
                    if node.module and node.module not in self.allowed_modules:
                        self.logger.warning(f"Prepovedan modul: {node.module}")
                        return False
        except SyntaxError:
            self.logger.warning("Sintaksna napaka v kodi")
            return False
        
        return True
    
    def _prepare_sandbox_context(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Pripravi sandbox context"""
        # Osnovni varni context
        safe_context = {
            '__builtins__': {
                'len': len,
                'str': str,
                'int': int,
                'float': float,
                'bool': bool,
                'list': list,
                'dict': dict,
                'tuple': tuple,
                'set': set,
                'range': range,
                'enumerate': enumerate,
                'zip': zip,
                'map': map,
                'filter': filter,
                'sorted': sorted,
                'sum': sum,
                'min': min,
                'max': max,
                'abs': abs,
                'round': round,
                'print': print
            }
        }
        
        # Dodaj varno filtrirane context podatke
        for key, value in context.items():
            if self._is_safe_value(value):
                safe_context[key] = value
        
        return safe_context
    
    def _is_safe_value(self, value: Any) -> bool:
        """Preveri, Äe je vrednost varna za sandbox"""
        # Dovoli osnovne tipe
        if isinstance(value, (str, int, float, bool, list, dict, tuple)):
            return True
        
        # PrepreÄi funkcije in module
        if callable(value) or hasattr(value, '__module__'):
            return False
        
        return True
    
    def _execute_in_sandbox(self, code: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Izvedi kodo v sandbox okolju"""
        try:
            # Ustvari sandbox datoteko
            sandbox_file = Path(self.temp_dir) / "sandbox_code.py"
            
            with open(sandbox_file, 'w') as f:
                f.write(code)
            
            # Izvedi z omejitvami
            start_time = self._get_deterministic_time() if hasattr(self, "_get_deterministic_time") else 1640995200
            
            # Uporabi subprocess za izolacijo
            process = subprocess.Popen(
                [sys.executable, str(sandbox_file)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=self.temp_dir,
                env=self._get_restricted_env()
            )
            
            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                execution_time = self._get_deterministic_time() if hasattr(self, "_get_deterministic_time") else 1640995200 - start_time
                
                return {
                    "success": process.returncode == 0,
                    "output": stdout.decode('utf-8'),
                    "error": stderr.decode('utf-8') if stderr else None,
                    "execution_time": execution_time,
                    "return_code": process.returncode
                }
                
            except subprocess.TimeoutExpired:
                process.kill()
                return {
                    "success": False,
                    "error": f"Execution timeout ({self.timeout}s)",
                    "output": None,
                    "execution_time": self.timeout
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "output": None
            }
    
    def _get_restricted_env(self) -> Dict[str, str]:
        """Pridobi omejeno okolje"""
        # Minimalno okolje
        restricted_env = {
            'PATH': '/usr/bin:/bin',
            'PYTHONPATH': '',
            'HOME': self.temp_dir,
            'TMPDIR': self.temp_dir
        }
        
        return restricted_env
    
    def _cleanup_sandbox(self):
        """PoÄisti sandbox"""
        if self.temp_dir and os.path.exists(self.temp_dir):
            try:
                shutil.rmtree(self.temp_dir)
                self.logger.info(f"Sandbox poÄiÅ¡Äen: {self.temp_dir}")
            except Exception as e:
                self.logger.error(f"Napaka pri ÄiÅ¡Äenju sandbox: {e}")

class ContentSandbox:
    """Sandbox za neoverjene vsebine"""
    
    def __init__(self):
        self.logger = logging.getLogger("MIA.ContentSandbox")
        self.quarantine_dir = Path("quarantine")
        self.quarantine_dir.mkdir(exist_ok=True)
    
    def quarantine_content(self, content: Any, content_type: str, reason: str) -> str:
        """Postavi vsebino v karanteno"""
        try:
            quarantine_id = f"quarantine_{int(self._get_deterministic_time() if hasattr(self, "_get_deterministic_time") else 1640995200)}"
            quarantine_path = self.quarantine_dir / quarantine_id
            
            # Shrani vsebino
            with open(quarantine_path, 'w') as f:
                if isinstance(content, str):
                    f.write(content)
                else:
                    f.write(str(content))
            
            # Logiraj karanteno
            self.logger.warning(f"Vsebina v karanteni: {quarantine_id}, razlog: {reason}")
            
            return quarantine_id
            
        except Exception as e:
            self.logger.error(f"Napaka pri karanteni: {e}")
            return ""
    
    def release_from_quarantine(self, quarantine_id: str) -> Optional[str]:
        """Sprosti vsebino iz karantene"""
        try:
            quarantine_path = self.quarantine_dir / quarantine_id
            
            if quarantine_path.exists():
                with open(quarantine_path, 'r') as f:
                    content = f.read()
                
                # IzbriÅ¡i iz karantene
                quarantine_path.unlink()
                
                self.logger.info(f"Vsebina sproÅ¡Äena iz karantene: {quarantine_id}")
                return content
            
            return None
            
        except Exception as e:
            self.logger.error(f"Napaka pri sproÅ¡Äanju iz karantene: {e}")
            return None

# Globalni sandbox instances
sandbox_environment = SandboxEnvironment()
content_sandbox = ContentSandbox()
